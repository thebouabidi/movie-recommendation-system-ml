<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TP Report</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>

  <nav class="navbar">
    <div class="container nav-inner">
      <div class="brand">
        <span class="logo">ðŸŽ¬</span>
        <span class="brand-name">MovieReco</span>
      </div>
      <div class="nav-links">
        <a href="{{ url_for('index') }}">Home</a>
        <a href="{{ url_for('report') }}" class="active">Report</a>
      </div>
    </div>
  </nav>

  <main class="container section report">
    <h1>TP 4 â€” Movie Recommendation System</h1>
    <p class="muted">
      Short academic explanation (A1 â†’ A6). This page matches the TP instructions.
    </p>

    <div class="card report-card">
      <h2>Quick dataset stats (after filtering)</h2>
      <ul>
        <li>Total ratings (raw): <strong>{{ stats.n_ratings_before }}</strong></li>
        <li>Total movies (raw): <strong>{{ stats.n_movies_total }}</strong></li>
        <li>Ratings after filtering: <strong>{{ stats.n_ratings_after }}</strong></li>
        <li>Users after filtering: <strong>{{ stats.n_users_after }}</strong></li>
        <li>Movies after filtering: <strong>{{ stats.n_movies_after }}</strong></li>
        <li>RMSE: <strong>{{ "%.4f"|format(stats.rmse) }}</strong></li>
      </ul>
    </div>

    <h2>A1 â€” Data exploration</h2>
    <p>
      We use the MovieLens dataset (ratings.csv + movies.csv). First, we check the main columns:
      userId, movieId, rating, timestamp, plus title/genres. We also look at basic statistics
      like min/max rating and the distribution of ratings. This helps understand if the dataset is balanced
      or if most ratings are concentrated around a few values.
    </p>

    <h2>A2 â€” Data preprocessing</h2>
    <p>
      We remove duplicates in ratings. Then we merge ratings with movies on movieId.
      Finally, to reduce noise and make the similarity more reliable, we filter:
      users with at least 20 ratings and movies with at least 20 ratings.
      This step is important because very inactive users (or rare movies) make similarity unstable.
    </p>

    <h2>A3 â€” Modeling</h2>
    <p><strong>1) Popularity-based baseline:</strong> we compute the mean rating for each movie and take the top-N.
      It is simple but not personalized.</p>
    <p><strong>2) User-based collaborative filtering:</strong> we build a user-movie matrix (ratings, missing = 0).
      Then we compute cosine similarity between users. For a target user, we take the most similar users
      (top K neighbors) and compute a weighted average of their ratings to predict unseen movies.</p>

    <h2>A4 â€” Train/Test split (conceptual)</h2>
    <p>
      In recommendation systems, we usually split interactions into train and test sets.
      The model learns user preferences from train ratings, and we evaluate predictions on the test ratings.
      In this project version, we compute RMSE on the known ratings matrix (masking zeros),
      which gives a quick idea of how close predictions are to existing ratings.
    </p>

    <h2>A5 â€” Evaluation (RMSE)</h2>
    <p>
      RMSE measures the average prediction error (penalizing bigger errors).
      We compute a predicted rating matrix using:
      predicted = S Ã— R / sum(|S|),
      where S is the similarity matrix and R is the rating matrix.
      Then we evaluate only on ratings that exist (R &gt; 0).
    </p>

    <h2>A6 â€” Personalized recommendations</h2>
    <p>
      For a given userId, we recommend the top-N movies with the highest predicted score
      among the movies the user has not rated yet. The result is personalized because it depends
      on the similarity with other users and their preferences.
    </p>

    <div class="card report-card">
      <h2>Note</h2>
      <p class="muted">
        This project keeps the implementation simple (Flask + HTML/CSS) and matches the TP workflow.
        The logic is directly adapted from the original notebook/script.
      </p>
    </div>
  </main>

  <footer class="footer">
    <div class="container">
      <span class="muted">End of report</span>
    </div>
  </footer>

</body>
</html> -->
